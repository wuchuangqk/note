# 字符类

| 符号   | 含义                              |
| ------ | --------------------------------- |
| [abc]  | 匹配 a、b 或 c 中的任意一个字符   |
| [^abc] | 匹配除 a、b、c 以外的任意一个字符 |
| [a-z]  | 匹配任意小写字母                  |
| [A-Z]  | 匹配任意大写字母                  |
| [0-9]  | 匹配任意数字                      |
| [^a-z] | 匹配除小写字母以外的任意一个字符  |

# 元字符

| 符号 | 含义                                           |
| ---- | ---------------------------------------------- |
| \w   | 数字、大小写字母、下划线[0-9a-zA-Z]            |
| \W   | 非数字、大小写字母、下划线[^0-9a-zA-Z]         |
| \d   | [0-9]                                          |
| \D   | 非数字[^0-9]                                   |
| .    | 匹配任意字符(换行符\n 除外)[^\n]               |
| \s   | 空白字符：空格、制表符、换行符、回车符[\t\n\r] |
| \S   | 非空白字符[^\t\n\r]                            |
| \b   | 匹配单词边界                                   |
| \B   | 匹配非单词边界                                 |

# 重复匹配

| 符号 | 含义             |
| ---- | ---------------- |
| \*   | 任意次数{0,}     |
| +    | 至少出现一次{1,} |
| ?    | 可有可无{0,1}    |

# 分组

| 符号         | 含义                                      |
| ------------ | ----------------------------------------- |
| (pattern)    | 匹配 pattern 并捕获匹配结果               |
| (?:pattern)  | 匹配 pattern 但不捕获匹配结果             |
| (?=pattern)  | 正向先行断言，匹配 pattern 前面的位置     |
| (?!pattern)  | 负向先行断言，匹配不在 pattern 前面的位置 |
| (?<=pattern) | 正向后行断言，匹配 pattern 后面的位置     |
| (?<!pattern) | 负向后行断言，匹配不在 pattern 后面的位置 |

# 单词边界

在正则表达式中，单词边界指的是单词字符和非单词字符之间的位置。

- 单词字符包括字母、数字和下划线。
- 非单词字符包括空格、标点符号等。

匹配单词边界可以用来确保匹配的是完整的单词，而不是单词的一部分。在正则表达式中，可以使用 \b 来表示单词边界。例如，正则表达式 \bhello\b 可以匹配单词 "hello"，但不会匹配 "hello123" 或者 "helloworld"。

# 捕获组

捕获组可以通过在正则表达式中使用括号来定义。捕获组可以用于后续的引用和替换操作。例如：

```javascript
const str = "Hello, world!";
const regex = /(Hello), (world)!/;
const match = str.match(regex);
console.log(match[0]); // Hello, world!
console.log(match[1]); // Hello
console.log(match[2]); // world!
```

在上面的例子中，正则表达式`/(Hello), (world)!/`定义了两个捕获组，分别匹配 "Hello" 和 "world!"。在 match 方法返回的结果中：

- match[0] 匹配整个正则表达式。
- match[1] 匹配第一个捕获组。
- match[2] 匹配第二个捕获组。

# 贪婪匹配

贪婪匹配是指正则表达式在匹配时尽可能地匹配更多的字符。非贪婪匹配则相反，尽可能地匹配更少的字符。在正则表达式中，贪婪匹配可以通过在重复匹配元字符后加上 ? 来实现非贪婪匹配。例如：

```javascript
const str = "aaaa";
const regex1 = /a+/; // 贪婪匹配
const regex2 = /a+?/; // 非贪婪匹配
console.log(str.match(regex1)); // ['aaaa']
console.log(str.match(regex2)); // ['a']
```

# 修饰符

修饰符是用于修改正则表达式匹配行为的标记。常见的修饰符包括 i（忽略大小写）、g（全局匹配）、m（多行匹配）等。例如：

```javascript
const str = "Hello, world!";
const regex = /hello/i; // 忽略大小写
console.log(str.match(regex)); // ['Hello']
const str = "aaa\nbbb\nccc";
const regex = /^b/gm; // 多行匹配
console.log(str.match(regex)); // ['b']
```

在上面的例子中，正则表达式 /hello/i 忽略了大小写，因此可以匹配到 "Hello"。正则表达式 /^b/gm 使用了多行匹配修饰符 m，因此可以匹配到多行字符串中以 "b" 开头的行。

# 分组与断言

在正则表达式中，分组可以将一些子模式组合在一起，并对这些子模式进行操作。分组可以使用圆括号来定义，圆括号内的模式会被视为一个整体。分组可以用来匹配、捕获、替换等操作。例如：

- `(abc)+`：匹配一个或多个连续的 "abc" 字符串。
- `(red|green|blue)`：匹配 "red"、"green" 或 "blue" 中的任意一个。
- `(\d{4})-(\d{2})-(\d{2})`：匹配日期格式，如 "2023-05-30"。

分组还可以使用反向引用，即在正则表达式中引用前面的分组。反向引用可以使用 \数字 的形式来表示，其中数字表示分组的序号。例如：

- `(\w)\1`：匹配连续出现两次的单词字符。
- `(<(\w+)>).*</\2>`：匹配 HTML 标签及其内容，其中 \2 表示第二个分组所匹配的内容。
  分组还可以使用非捕获分组 (?:)，它可以用来对分组进行分组，但不会被捕获到分组中。例如：

- `(?:ab)+`：匹配一个或多个连续的 "ab" 字符串，但不会将每个 "ab" 字符串作为一个分组捕获。
- `(?:red|green|blue)`：匹配 "red"、"green" 或 "blue" 中的任意一个，但不会将它们作为分组捕获。

## 断言

在正则表达式中，分组里可以使用断言来匹配**某些位置**，而不是匹配具体的字符。断言分为正向断言和负向断言，其中正向断言匹配成功的条件是其后面的内容符合断言，而负向断言则相反，匹配成功的条件是其后面的内容不符合断言。

正向断言使用 (?=) 表示，负向断言使用 (?!) 表示。例如：

- `(?=\d{2})\d{4}-\d{2}-\d{2}`：匹配日期格式，前四个数字表示年份，后面的 - 符号和后面的两个数字表示月份和日期，其中 (?=\d{2}) 表示后面必须是两个数字。
- `(?<=\$)\d+\.\d{2}`：匹配货币格式，其中 $ 符号表示美元符号，\d+\.\d{2} 表示两位小数的数字，其中 (?<=\$) 表示前面必须是美元符号。
- `(?<!abc)def`：匹配 "def"，其中 (?<!abc) 表示前面不能是 "abc"。

需要注意的是，断言并不会消耗字符，也就是说，匹配结果中不会包含断言的内容。

正向断言表示只有在匹配到某个模式时，才会继续往后匹配。正向断言使用 `(?=pattern)` 的语法进行表示，其中 `pattern` 是要匹配的模式。例如，假设我们想匹配一个字符串中所有以 `http` 开头的 URL，但不包括 `http` 前缀本身，可以使用如下正则表达式：

```
/(?<=http:\/\/)[^\s]+/g
```

这个正则表达式中使用了正向断言 `(?<=http:\/\/)`，表示只有在 `http://` 后面紧跟着一段非空白字符时才会匹配成功。其中 `[^\\s]+` 表示匹配一个或多个非空白字符。

反向断言则表示只有在匹配到某个模式之前，才会继续往前匹配。反向断言使用 `(?<=pattern)` 的语法进行表示，其中 `pattern` 是要匹配的模式。例如，假设我们想匹配一个字符串中所有以 `jpg` 结尾的 URL，但不包括 `jpg` 后缀本身，可以使用如下正则表达式：

```
/(?<=\.)[^\.\/]+\.(jpg|jpeg|png|gif)/g
```

这个正则表达式中使用了反向断言 `(?<=\.)`，表示只有在一个点符号 `.` 前面紧跟着一段非点符号和非斜杠符号的字符时才会匹配成功。其中 `[^\\./]+` 表示匹配一个或多个非点符号和非斜杠符号的字符。

总之，断言是一种非常强大的正则表达式功能，可以帮助我们更加精确地匹配字符串中的内容。

# 方法

JS 正则对象有以下常用的方法：

- `test(str)`：检测字符串 str 中是否包含正则表达式模式，返回布尔值。
- `exec(str)`：在字符串 str 中查找正则表达式模式，返回匹配结果数组或 null。
- `match(str)`：在字符串 str 中查找正则表达式模式，返回匹配结果数组或 null。
- `search(str)`：在字符串 str 中查找正则表达式模式，返回匹配结果的位置或 -1。
- `replace(str, replacement)`：在字符串 str 中查找正则表达式模式，并用 replacement 替换匹配的部分，返回替换后的新字符串。

此外，正则对象还有一些用于获取正则表达式模式和标志的属性，如 source 和 flags。

## exec

```javascript
const str = "hello world";
const regex = /hello (\w+)/;
const result = regex.exec(str);

console.log(result); // ["hello world", "world"]
console.log(result[0]); // "hello world"
console.log(result[1]); // "world"
```

在这个例子中，正则表达式 /hello (\w+)/ 匹配了字符串 hello world，其中 (\w+) 是一个分组，捕获了单词 world。exec 方法返回了一个数组，第一个元素是匹配的字符串 "hello world"，第二个元素是分组捕获的内容 "world"。

如果正则表达式中有多个分组，exec 方法返回的数组中会包含所有分组的内容。例如：

```javascript
const str = "2023-05-30";
const regex = /(\d{4})-(\d{2})-(\d{2})/;
const result = regex.exec(str);

console.log(result); // ["2023-05-30", "2023", "05", "30"]
console.log(result[1]); // "2023"
console.log(result[2]); // "05"
console.log(result[3]); // "30"
```

在这个例子中，正则表达式 /(\d{4})-(\d{2})-(\d{2})/ 匹配了日期字符串 2023-05-30，其中 (\d{4})、(\d{2}) 和 (\d{2}) 是三个分组，分别捕获了年、月和日。exec 方法返回了一个数组，第一个元素是匹配的字符串 "2023-05-30"，后面三个元素分别是三个分组捕获的内容 "2023"、"05" 和 "30"。

需要注意的是，exec 方法每次只返回一个匹配结果，如果要找到所有匹配的结果，需要使用循环来多次调用该方法，直到返回 null。例如：

```javascript
const str = "hello world, hello everyone";
const regex = /hello (\w+)/g;
let result;

while ((result = regex.exec(str)) !== null) {
  console.log(result[1]);
}
```

在这个例子中，正则表达式 /hello (\w+)/g 使用了全局匹配标志 g，表示要找到所有匹配的结果。然后通过循环调用 exec 方法，每次找到一个匹配的结果，并输出分组捕获的内容。

## match

match 是 JavaScript 字符串对象的一个方法，用于在字符串中执行正则表达式搜索，并返回匹配的结果。它的语法如下：

```javascript
str.match(regexObj);
```

其中，str 是一个要被搜索的字符串，regexObj 是一个正则表达式对象。该方法返回一个数组，其中包含了所有匹配的结果。如果没有匹配到任何内容，则返回 null。

与 exec 方法不同的是，match 方法不返回分组捕获的内容，只返回匹配的字符串。如果正则表达式中有多个分组，match 方法只返回第一个分组捕获的内容。如果要获取所有分组捕获的内容，需要使用 exec 方法。

下面是一个例子，演示了 match 方法的基本用法：

```javascript
const str = "hello world";
const regex = /hello (\w+)/;
const result = str.match(regex);

console.log(result); // ["hello world", "world"]
console.log(result[0]); // "hello world"
console.log(result[1]); // "world"
```

在这个例子中，正则表达式 /hello (\w+)/ 匹配了字符串 hello world，其中 (\w+) 是一个分组，捕获了单词 world。match 方法返回了一个数组，第一个元素是匹配的字符串 "hello world"，第二个元素是分组捕获的内容 "world"。

如果正则表达式中有多个分组，match 方法只返回第一个分组捕获的内容。例如：

```javascript
const str = "2023-05-30";
const regex = /(\d{4})-(\d{2})-(\d{2})/;
const result = str.match(regex);

console.log(result); // ["2023-05-30", "2023", "05", "30"]
console.log(result[1]); // "2023"
console.log(result[2]); // "05"
console.log(result[3]); // "30"
```

在这个例子中，正则表达式 /(\d{4})-(\d{2})-(\d{2})/ 匹配了日期字符串 2023-05-30，其中 (\d{4})、(\d{2}) 和 (\d{2}) 是三个分组，分别捕获了年、月和日。match 方法返回了一个数组，第一个元素是匹配的字符串 "2023-05-30"，后面三个元素分别是三个分组捕获的内容 "2023"、"05" 和 "30" 中的第一个。

需要注意的是，如果正则表达式中包含全局匹配标志 g，则 match 方法会返回所有匹配的结果。例如：

```javascript
const str = "hello world, hello everyone";
const regex = /hello (\w+)/g;
const result = str.match(regex);

console.log(result); // ["hello world", "hello everyone"]
```

在这个例子中，正则表达式 /hello (\w+)/g 使用了全局匹配标志 g，表示要找到所有匹配的结果。然后通过 match 方法找到了所有匹配的结果，并返回一个数组。
